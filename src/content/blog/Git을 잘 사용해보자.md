---
title: Git, 어떻게 해야 잘쓰는 걸까?
pubDate: 2025-10-15
description: git을 맛있게 쓰자
author: KT
tags:
  - git
  - github
---
## Git은 타임스톤이다.
Git은 "버전 관리 시스템"이다. 코드의 변경 이력을 기록하고 관리하는 도구이다. 버전을 관리해주고, 분산 저장 시스템이며...(주저리 주저리)

내가 느낀 깃은 그냥 "타임스톤"이다. 언제든지 내가 원하는 시점의 코드로 되돌릴 수 있다.
![Git을 잘 사용해보자-20251015-1.png](/images/blog/Git을 잘%20사용해보자-20251015-1.png)
- 코드를 수정했는데, 영 마음에 들지않는다 원상 복구하자
- 오늘 개발한 이 기능은 필요 없을 것 같으니 되돌리자
- 너가 이 시점까지 만든 코드랑 내가 방금 만든 코드랑 합치자

내가 언제 어디까지 했는지 저장만 해뒀다면, 그 시점으로 언제든지 되돌아 갈 수 있다. 그게 바로 깃이다.

## Git 올바르게 사용하자
깃이 뭐하는 놈인지는 알았는데, 사용법이라는게 있을까? 무조건 이렇게 써야한다는 없지만, 어떻게 하면 깃을 잘 활용하는지 알고 싶었습니다. Git 명령어들을 다양하게 알고, 적재적소에 사용하는 것도 좋지만 어떻게 하면 맛있게 쓸 수 있을까에 대해 알아봤다.

#### Git은 자주 그리고 의미있게
자주? 그냥 생각날때마다, `git add`하면 되나? 자주라는 단어에 명확한 기준은 없지만, 시간이 기준이 될 수도 있고(n시간마다, 하루마다) 작은 기능하나가 기준이 될 수도 있다. 일관된 기준이 있어야, 내가 원하는 시점을 선택하기가 용이하다.

커밋에 의미가 있어야한다는 것은 해당 커밋이 어느정도 완결된 작업 단위여야 한다는 것이다. 개발 50% 진행됨, 임시 저장, 이것 저것 만져봄과 같은 내용들은 해당 기점으로 돌아갈 확률도 거의 없고, 오히려 버전관리를 힘들게 한다. 문서를 완전 수정했을때, 버그를 고쳤을때, 기능 구현이 완료 됐을때처럼 작게라도 하나의 완성된 과정을 기준으로 저장하는 것이 바람직하다. 

#### `git add .`를 지양하자
무분별한 `git add .` 사용을 지양해야 한다. 그때그때 파일을 전부 커밋/푸시하면 편하긴하다. 하지만, 불필요한 파일들이 푸시되면, 다른 pc에서 개발을 할 때 문제가 생기거나, 수정된 파일들을 추적할 때 불편해질 수가 있다. 불필요한 파일들이라 하면 빌드의 결과물, 의존성, IDE 설정과 같이 로컬에서 생성 되는 파일들을 말한다. 커밋한 내용에 맞는 수정사항만 푸시하는 습관을 길러보자. `.gitignore`를 활용하면, 불필요한 파일들이 커밋되는 상황을 조금 더 쉽게 관리할 수 있다.

#### 깃 컨벤션, 깃모지를 활용하자.
깃 컨벤션은 깃을 사용할 때 커밋을 작성하는 일관된 규칙을 말한다. 일관된 규칙으로 커밋을 작성하면, 히스토리의 가독성이 올라가고, 내가 작성한 커밋이 아니더라도 변경사항들의 파악이 빨라진다. 추가로 자동화 툴들도 활용가능하다고 한다. 잘 정리된 자료를 따로 아래 공유하겠습니다.
깃컨벤션+깃모지 : https://velog.io/@archivvonjang/Git-Commit-Message-Convention
깃모지 : https://gitmoji.dev
Conventional Commits : https://www.conventionalcommits.org/en/v1.0.0/


#### 명확한 브랜치 전략을 따르자
GitFlow, GitHubFlow, GitLabFlow 여러 방식이 존재하지만, Git Flow만 알아보도록 하겠습니다. Git Flow방식은 가장 체계적이고 복잡한 전략입니다. 아마 다른 브랜치 전략들은 크게 어렵지 않을 것 같습니다.
###### 브랜치 구조
- `main`/`master` : 배포된 프로덕션 코드
- `develop` : 다음 릴리스를 위한 개발 브랜치
- `feature/*` : 새 기능 개발 (`develop`에서 분기하고, `develop`에서 병합)
- `release/*` : 릴리스 준비 (`develop`에서 분기하고, `main`과 `develop` 둘 다 병합)
- `hotfix/*` : 긴급 버그 수정 (`main`에서 분기하고, `main`과 `develop` 둘다 병합)

###### 작업 흐름
1. 새 기능을 만들기 위해 `develop`에서 `feature/*` 생성
2. 기능 완성 후 `develop`에 병합
3. `develop`에서 `release/1.0.1` 생성
4. 테스트/버그 수정 후 `main`/`develop`에 병합

#### main 브랜치는 항상 배포 가능한 상태를 유지하자
배포 가능한 상태의 조건들은 다음과 같습니다.
- 코드가 컴파일/빌드되고 실행된다
- 모든 테스트를 통과한다
- 치명적인 버그가 존재하지 않는다
위 상태를 유지하려면 직접 커밋하는 방식은 사용하지 않는다. PR/MR을 거쳐서 merge 해야한다. 혼자서 main 브랜치에 바로 푸시하면, 협업하는 다른 개발자들이 코드를 검토할 수가 없이 푸시되어 버린다. PR/MR을 활용하면, Github Actions로 테스트하거나 다른 사람들이 코드를 살펴보고 문제가 없는지 확인할 수 있게 된다.









