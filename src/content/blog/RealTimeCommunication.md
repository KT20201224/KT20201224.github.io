---
title: 실시간 통신과 웹소켓
pubDate: 2025-11-29
description: 실시간 통신을 학습하고 네트워크에 대한 이해를 키워본다.
author: KT
tags:
  - WebScoket
  - Netwrok
  - TCP
  - Polling
---
실시간 소통(Real-Time Communication)과 소켓(Socket)은 네트워크/백엔드/프론트엔드 나눌 것 없이 서비스를 개발하려면 반드시 알아야하는 주제이다. 이번 기회에 부족했던 개념들을 한번에 정리하고자 한다.

우선 Web통신을 알아야 합니다. 웹 통신은 기본적으로 클라이언트와 서버 간의 상호작용을 기반으로 합니다. 이를 "클라이언트 - 서버 모델"이라고 부릅니다. 클라이언트는 주로 웹브라우저와 같이 사용자의 요청을 보내는 역할을 하고 서버는 이러한 요청을 처리하고 응답(반환)하는 역할을 합니다. 

![WebSocket-20251129-1.png](/images/blog/WebSocket-20251129-1.png)

HTTP는 웹 통신을 위한 기본 프로토콜로 서버와 클라이언트가 데이터를 주고받기 위한 규약이라고 이해하면 된다. 위 구조에서 요청을 HTTP Request, 응답을 HTTP Response라고 한다. 이때 HTTP 통신은 응답(HTTP Response)를 받으면 연결이 끊어지는 특징이 있습니다. 이를 HTTP의 핵심 특징인 **비연결성(Connectionless)** 이라고 합니다. 그래서 웹은 실시간으로 서비스를 운영할 수 없는 한계가 존재합니다. 이를 마치 "실시간인 것처럼" 하는 기술이 Polling이라는 기술입니다.

## Polling
Polling은 클라이언트가 일정 시간마다 서버에 새로운 데이터가 존재하는지 요청을 보내는 방식이다. 예를 들어, SNS 서비스에 폴링을 적용한다면
1. 첫 렌더링이 될 때, 서버에서 API 요청이 발생
2. 이후 N초마다 새 글이 있는지 확인하기 위해 클라이언트 측에서 API 요청을 보냄
3. 새 글이 존재하면 응답을 받고, 클라이언트 측에서 리렌더링
4. N초 후 다시 새 글이 존재하는지 API 요청

![WebSocket-20251129-2.png](/images/blog/WebSocket-20251129-2.png)

HTTP만 알고 있다면 주기적으로 요청만 보내주면 되기에 구현이 아주 쉽습니다. 하지만 갱신사항의 존재 유무와 상관없이 지속적으로 요청을 날리기 때문에, 트래픽이 낭비되고 사용자가 많아진다면 서버 부하가 커집니다. 또 일정 주기로 응답을 받아오기 때문에 진짜 실시간이라고 보기엔 어렵다.

## Long Polling
Long Polling은 요청을 서버로 보내면 지정된 시간동안 대기합니다. 새 데이터가 생기면 서버는 클라이언트에게 응답을 보내 연결을 종료합니다. 제한 시간 동안 요청이 완료되지 않으면 timeout을 전달하고, 클라이언트는 새로운 요청을 만들어서 요청-응답 주기를 생성한다. 즉, 서버 측에서 접속을 열어두는 방식이다.

![WebSocket-20251129-3.png](/images/blog/WebSocket-20251129-3.png)

같은 주기로 계속 요청을 보내는 Polling보다는 효율적이다. 조금 더 실시간에 가까워진 방식이지만 연결을 유지해야 하기 때문에 서버가 많은 연결을 처리해야 한다. 사용자가 많은 환경에서는 비효율적이다.

## TCP 소켓
TCP 소켓을 공부하려면 우선 TCP가 무엇인지 알아야한다. TCP는 Transmission Control Protocol의 약자로 네트워크를 통해 두 애플리케이션이 데이터를 신뢰성 있게 교환할 수 있도록 하는 통신 표준입니다. TCP/IP 4계층을 기준으로 HTTP/WebSocket/SSE는 Application layer에 존재하고, TCP는 그 아래 Transport layer에서 데이터를 안정적으로 보내주는 역할을 합니다. 

#### IP, Port, 프로세스
앞으로 사용될 용어인 IP, Port, 프로세스를 간단하게 정리만 하고 가겠습니다.
1. IP : 어느 컴퓨터로 가야하는지 
	- 192.168.0.10
2. Prot : 컴퓨터 안에 어떤 프로그램(프로세스)와 통신할 것인가 
	- 80(HTTP)
	- 443(HTTPS)
	- 3306(MySQL)
3. 프로세스 : 우리가 작성한 서버 프로그램

#### TCP
이제 주소는 알았다. 근데 "어떻게 보낼까?"를 아직 다루지 않았는데 이 역할을 하는 것이 TCP(Transmission Control Protocol)이다. 이 TCP의 역할은 크게 4가지가 존재한다.
1. Connection-oriented : "우리 연결하자"라고 합의(handshake)하고나서 데이터를 주고 받는다.
2. Reliable : 중간에 데이터가 일부 사라지면 다시 보내달라 요청한다. 데이터가 깨졌는지 체크(체크섬)하고 빠진 부분이 없이 받도록 해준다.
3. Ordered : 먼저 보낸 데이터가 나중에 도착해도 받는 쪽에서는 원래 순서대로 받도록 조정해준다.
4. Stream : 패킷 하나하나 대신 바이트가 이어지는 형태의 데이터 흐름을 제공한다.

즉, 데이터를 안전하게 형태가 변형되지 않게 보내주는 규칙입니다.

###### 3-Way handshake
TCP가 연결에 대해 합의하는 과정을 handshake라고 표현했는데, 그 흐름을 3-Way handshake라고 하고, 다음과 같은 과정으로 이루어집니다.
1. 클라이언트 -- (SYN) --> 서버  : "우리 연결해요!(SYN)"
2. 서버 -- (ACK + SYN) --> 클라이언트 : "좋아 접속 받아줄게(SYN)" / "요청 확인했어(ACK)"
3. 클라이언트 -- (ACK) --> 서버 : "나도 네 SYN 잘 받았어!(ACK)"

이 3단계를 거치고 서로 데이터를 보내고 받을 수 있는 TCP 연결이 완성됍니다. 이제 이 연결 위에서 HTTP, WebScoket 같은 프로토콜을 자유롭게 올려서 사용할 수 있게 됩니다.

#### 소켓
TCP가 뭔지 알았으니 이제 소켓이 뭔지 알아보겠습니다. 소켓은 OS가 만들어주는 "네트워크 통신용 객체/파일"이다. 이 안에는 내 IP/Port, 상대 IP/Port, TCP 연결 상태, 송수신 버퍼 같은 정보들이 들어있다. 리눅스/맥 관점에서는 소켓을 그냥 파일 디스크립터의 일종이라고도 할 수 있다. 우리가 파일에 read()/wirte() 하듯이 소켓에recv()/send()를 합니다. 


#### TCP 소켓 동작과정
위에서 필요한 개념들은 모두 정리했으니 이제 TCP 소켓이 어떻게 동작하는지 알아보겠습니다. 
![All_of_Network-20251130-3.png](/images/blog/All_of_Network-20251130-3.png)

###### Server Socket flow
1. socket() : 통신용 소켓을 생성한다. 현재는 아무 주소와도 연결되지 않은 상태
2. bind(ip,port) : 해당 IP/Port로 요청을 받겠다고 설정
3. listen() : 포트를 열어두고 접속자를 기다리는 대기 상태 진입
4. accept() : 3way-handshake가 끝나고, 서버에서 새로운 소켓을 하나 생성해서 반환한다. 클라이언트와 연결된 전용 소켓이 생성된다. 이 소켓은 클라이언트를 기다리려고 만든 소켓과는 실제 다른 클라이언트와의 통신용 소켓
5. send() & recv() : 만들어진 소켓으로 양방향 통신을 진행
6. close() : 연결 종료

###### Client Socket flow
1. socket() : 클라이언트 소켓 생성
2. connenct(server ip, port) : 서버로 연결 요청을 전송한다. 연결이 확정되면 서버의 accept()로 이어진다.
3. send() & recv() : 만들어진 소켓으로 양방향 통신을 진행
4. close() : 연결 종료

###### 주의할점
1. listen()의 대기용 소켓과 accept()의 통신용 소켓은 다르다.
2. connect() ~ accept() 과정에 마무리가 "TCP 연결"이다. 이 과정에서 3way-handshake가 내부적으로 발생한다.
3. 연결이 완료되고 양쪽 소켓에서는 그냥 단순하게 send()/recv만 하면된다.